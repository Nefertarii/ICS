1
---------
/* 
 * bitXor - x^y using only ~ and & 
 *   Example: bitXor(4, 5) = 1
 *   Legal ops: ~ &
 *   Max ops: 14
 *   Rating: 1
 */
int bitXor(int x, int y)
{
  /*
  暂未想出原因 暴力解出的
  */
  return ~(~(~(x & y) & x) & ~(~(x & y) & y));
  //~(~x & ~y) & ~(x & y);
}

2
---------
/* 
 * tmin - return minimum two's complement integer 
 *   Legal ops: ! ~ & ^ | + << >>
 *   Max ops: 4
 *   Rating: 1
 */
int tmin(void)
{
  /*
  最长32位字节 Tmin = 1000...0 直接逻辑位移
  */
  return 1 << 31;
}

3
---------
/*
 * isTmax - returns 1 if x is the maximum, two's complement number,
 *     and 0 otherwise 
 *   Legal ops: ! ~ & ^ | +
 *   Max ops: 10
 *   Rating: 1
 */
int isTmax(int x)
{
  /*
  利用异或性质0异或任何数等于其本身
  如果是Tmax tmp1为0 tmp为全0 取非后为1  return 0^1 = 1 
  如果是-1 tmp为1 tmp为0 取非后为1 return 1^1 = 0
  如果是其他任何数如 2  tmp1为0  tmp2不为0 取非后为0  return 0^0 = 0
  */
  int tmp1 = !(x + 1);
  int tmp2 = !((x + 1) ^ (~x));
  return tmp1 ^ tmp2;
}

4
---------
/* 
 * allOddBits - return 1 if all odd-numbered bits in word set to 1
 *   where bits are numbered from 0 (least significant) to 31 (most significant)
 *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
 *   Legal ops: ! ~ & ^ | + << >>
 *   Max ops: 12
 *   Rating: 2
 */
int allOddBits(int x)
{
  /*
  掩码1010...1010
  取得x的奇数位1 再与掩码异或
  若x奇数位全为1 异或得0
  返回时取非 上一步得0返回1 否则返回0
  */
  int mask = (int)0xAAAAAAAA;
  x = x & mask;
  x = x ^ mask;
  return !x;
}

5
---------
/* 
 * negate - return -x 
 *   Example: negate(1) = -1.
 *   Legal ops: ! ~ & ^ | + << >>
 *   Max ops: 5
 *   Rating: 2
 */
int negate(int x)
{
  /*
  取反再+1
  */
  return (~x) + 1;
}

6
---------
/* 
 * isAsciiDigit - return 1 if 0x30 <= x <= 0x39 (ASCII codes for characters '0' to '9')
 *   Example: isAsciiDigit(0x35) = 1.
 *            isAsciiDigit(0x3a) = 0.
 *            isAsciiDigit(0x05) = 0.
 *   Legal ops: ! ~ & ^ | + << >>
 *   Max ops: 15
 *   Rating: 3
 */
int isAsciiDigit(int x)
{
  /*
  upper 0x39  0011 1001b 加上比0x39大的数后符号由正变负
  lower 0x30  0011 0000b 加上比0x30小的值时是负数
  返回取符号位 全0返回0 否则返回1
  */
  int sign = 0x1 << 31;
  int upper = ~(sign | 0x39);
  int lower = ~0x30;
  upper = sign & (upper + x) >> 31;
  lower = sign & (lower + 1 + x) >> 31;
  return !(upper | lower);
}

7
---------
int isAsciiDigit(int x)
{
  /*
  upper 0x39  0011 1001b 加上比0x39大的数后符号由正变负
  lower 0x30  0011 0000b 加上比0x30小的值时是负数
  返回取符号位 全0返回0 否则返回1
  没弄明白 回头再看
  */
  int sign = 0x1 << 31;
  int upper = ~(sign | 0x39);
  int lower = ~0x30;
  upper = sign & (upper + x) >> 31;
  lower = sign & (lower + 1 + x) >> 31;
  return !(upper | lower);
}

8
---------
/* 
 * conditional - same as x ? y : z 
 *   Example: conditional(2,4,5) = 4
 *   Legal ops: ! ~ & ^ | + << >>
 *   Max ops: 16
 *   Rating: 3
 */
int conditional(int x, int y, int z)
{
  /*
  x=true return y else return z
  先对x取非 构造成全0或者全1
  利用获得的x作为掩码 
  进行(z&x),(y&~x)操作 必定有一侧为全0
  利用或操作 (z|y) 选择出需要的数字
  */
  x = (!x) << 31;
  return (z & x) | (y & ~x);
}

9
---------
/* 
 * isLessOrEqual - if x <= y  then return 1, else return 0 
 *   Example: isLessOrEqual(4,5) = 1.
 *   Legal ops: ! ~ & ^ | + << >>
 *   Max ops: 24
 *   Rating: 3
 */
int isLessOrEqual(int x, int y)
{
  /*
  先判断符号位
  符号位相同两数相减 再判断符号位
  sign1若为1 则x > y  否则为等于或小于 判断符号
  sign2若为1 则x = y  否则为大于或小于 大于在sign1已经判断 判断符号
  sign3若为1 则x < y  否则为大于或等于 y-x取符号位再取非 但不能使用 - 符号
  */
  int signx = x >> 31;
  int signy = y >> 31;
  int sign1 = (signx & !signy);
  int sign2 = (!(signx ^ signy);
  int sign3 = !((y + ~x + 1) >> 31));
  return sign1 | (sign2 & sign3);
}

10
----------
/* 
 * logicalNeg - implement the ! operator, using all of 
 *              the legal operators except !
 *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1
 *   Legal ops: ~ & ^ | + << >>
 *   Max ops: 12
 *   Rating: 4 
 */
int logicalNeg(int x)
{
  /*
  利用其补码的性质 除了0和Tmin外其他数都是互为相反数关系
  0和最小数的补码是本身 不过0的符号位与其补码符号位位或为0 最小数的为1
  */
  return ((x | (~x + 1)) >> 31) + 1;
}

