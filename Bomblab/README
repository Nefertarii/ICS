压缩包中只有可运行的文件和用于提示的bomb.c  
利用objdump -d 将炸弹的asm文件保存下来即可开始分析  
  
   

根据给出的.c文件 可以确定程序有6个阶段 每个阶段都需要正确的输入才能进入下一阶段  
也可以通过文件读取输入(应该是按行读取)
把文件传输到了Windows上 通过vscode方便文件的查看

**phase_1:**
在第一阶段之前有函数 initialize_bomb   
一开始认为该函数里面可能会有线索 但并没有相关内容 只是单纯的初始化
简单略过后 发现了触发爆炸的函数:explode_bomb 在此设置了断点并开始分析

从main 进入phase1:
发现phase1中一个函数名已经给出了很明显的提示 "strings_not_equal"  
并且在进入该函数之前 有语句mov $0x402400,%esi  
表明了将$0x402400写入%esi 且作为第二参数传入到了函数:strings_not_equal中
(第一参数在地址400e37:mov %rax,%rdi  查找发现在地址40133c有操作mov %rdi,%rbx 又经过对栈内容的确认 知道了%rdi保存了在进入phase1之前所输入的字符串)  
根据函数名推测可能是用于对比输入与该位置保存的数据是否一致 于是使用x/s 0x402400  
发现了字符串 Border relations with Canada have never been better.(获得后立马就在调试下输入并通过了第一阶段 然后又返回来继续查看汇编文件)

进入函数strings_not_equal中:
401338~40133f: %rbx保存了%rdi的数据(%rdi为输入的字符串) %rbp保存了%rsi的数据(%rsi为内存中所保存密码)
401342:        进入函数:string_length 对其分析后该函数通过cmpb不断对比传入的参数%rdi中保存的字符
               若不为0 则对返回值%eax和%rdi的对比位置+1 直到对比为0 返回返回值%eax  
               可以发现函数:string_length用于返回字符串的长度
40133c~40135a: 继续进行函数:strings_not_equal的分析发现调用了两次string_length 一次调用了%rsi 一次调用了%rdi
               可以确定函数到该位置是用于对比输入与保存的字符串长度是否一致 一致则继续流程 否则转跳至返回位置并返回1(也能确定函数:string_not_equals返回1则表示失败)
               继续进行 在地址40135c进行了操作:movzbl (%rbx),%eax 并进行对比 test %al,%al
               相同转跳至地址401388处并返回0 不同则继续进行流程
40135c~401361: (这一步一没一开始想明白 为什么对比一个就能确定返回0 后来猜想应该是编译器的原因 
               %rbx保存了作为输入传入的%rdi 而%rdi在经过上一步判断了长度第一位不可能为0 所以只是为了下面的操作而保存至%eax)
401363~401368: 继续进行 在地址401363进行cmp 0x0(%rbp),%al 比较rbp的第一个字符和%al(%al在上一步已经被保存了%rbx的第一个字符) 相同转跳地址401372 否则转跳地址40138f 并返回1
40136a~401386: 地址401372对上述两个字符串的位置分别+1后继续对比是否为0 不为0则转跳地址40136a重复进行比对 为0则继续流程从而返回0
